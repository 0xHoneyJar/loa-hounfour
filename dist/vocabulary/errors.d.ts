/**
 * Standard error codes shared across loa-finn and arrakis.
 */
export declare const ERROR_CODES: {
    readonly JWT_INVALID: "JWT_INVALID";
    readonly JWT_EXPIRED: "JWT_EXPIRED";
    readonly JTI_REQUIRED: "JTI_REQUIRED";
    readonly JTI_REPLAY: "JTI_REPLAY";
    readonly ISSUER_NOT_ALLOWED: "ISSUER_NOT_ALLOWED";
    readonly AUDIENCE_MISMATCH: "AUDIENCE_MISMATCH";
    readonly REQ_HASH_MISMATCH: "REQ_HASH_MISMATCH";
    readonly TIER_INSUFFICIENT: "TIER_INSUFFICIENT";
    readonly JWKS_UNAVAILABLE: "JWKS_UNAVAILABLE";
    readonly BUDGET_EXCEEDED: "BUDGET_EXCEEDED";
    readonly BUDGET_OVERFLOW: "BUDGET_OVERFLOW";
    readonly RATE_LIMITED: "RATE_LIMITED";
    readonly CONTRACT_VERSION_MISMATCH: "CONTRACT_VERSION_MISMATCH";
    readonly POOL_UNKNOWN: "POOL_UNKNOWN";
    readonly BODY_TOO_LARGE: "BODY_TOO_LARGE";
    readonly ENCODING_UNSUPPORTED: "ENCODING_UNSUPPORTED";
    readonly DECOMPRESSION_BOMB: "DECOMPRESSION_BOMB";
    readonly PROVIDER_UNAVAILABLE: "PROVIDER_UNAVAILABLE";
    readonly PROVIDER_TIMEOUT: "PROVIDER_TIMEOUT";
    readonly PROVIDER_ERROR: "PROVIDER_ERROR";
    readonly MODEL_UNAVAILABLE: "MODEL_UNAVAILABLE";
    readonly NATIVE_RUNTIME_SPAWN_FAILED: "NATIVE_RUNTIME_SPAWN_FAILED";
    readonly NATIVE_RUNTIME_TIMEOUT: "NATIVE_RUNTIME_TIMEOUT";
    readonly NATIVE_RUNTIME_ORPHAN: "NATIVE_RUNTIME_ORPHAN";
    readonly ENSEMBLE_ALL_FAILED: "ENSEMBLE_ALL_FAILED";
    readonly BYOK_SESSION_EXPIRED: "BYOK_SESSION_EXPIRED";
    readonly BYOK_BOUNDED_USE_EXCEEDED: "BYOK_BOUNDED_USE_EXCEEDED";
    readonly BYOK_NONCE_REPLAY: "BYOK_NONCE_REPLAY";
    readonly RECONCILIATION_DRIFT: "RECONCILIATION_DRIFT";
    readonly RECONCILIATION_FAIL_CLOSED: "RECONCILIATION_FAIL_CLOSED";
    readonly SSE_PARSE_ERROR: "SSE_PARSE_ERROR";
    readonly AGENT_NOT_FOUND: "AGENT_NOT_FOUND";
    readonly AGENT_NOT_ACTIVE: "AGENT_NOT_ACTIVE";
    readonly AGENT_TRANSFER_IN_PROGRESS: "AGENT_TRANSFER_IN_PROGRESS";
    readonly CONVERSATION_SEALED: "CONVERSATION_SEALED";
    readonly CONVERSATION_NOT_FOUND: "CONVERSATION_NOT_FOUND";
    readonly OWNERSHIP_MISMATCH: "OWNERSHIP_MISMATCH";
    readonly BILLING_RECIPIENTS_INVALID: "BILLING_RECIPIENTS_INVALID";
    readonly ROUTING_CONSTRAINT_VIOLATED: "ROUTING_CONSTRAINT_VIOLATED";
    readonly SANCTION_ACTIVE: "SANCTION_ACTIVE";
    readonly SANCTION_APPEAL_DENIED: "SANCTION_APPEAL_DENIED";
    readonly DISPUTE_NOT_FOUND: "DISPUTE_NOT_FOUND";
    readonly DISPUTE_ALREADY_RESOLVED: "DISPUTE_ALREADY_RESOLVED";
    readonly REPUTATION_INSUFFICIENT: "REPUTATION_INSUFFICIENT";
    readonly ESCROW_NOT_FOUND: "ESCROW_NOT_FOUND";
    readonly ESCROW_INVALID_STATE: "ESCROW_INVALID_STATE";
    readonly STAKE_INSUFFICIENT: "STAKE_INSUFFICIENT";
    readonly CREDIT_LIMIT_EXCEEDED: "CREDIT_LIMIT_EXCEEDED";
    readonly CREDIT_LINE_NOT_FOUND: "CREDIT_LINE_NOT_FOUND";
    readonly DIVIDEND_NOT_DECLARED: "DIVIDEND_NOT_DECLARED";
};
export type ErrorCode = (typeof ERROR_CODES)[keyof typeof ERROR_CODES];
/**
 * Canonical HTTP status mapping for error codes.
 *
 * Ensures arrakis and loa-finn return consistent HTTP statuses
 * for the same error conditions. Without this, intermediaries
 * (load balancers, API gateways) cannot make correct routing
 * decisions based on HTTP status alone.
 *
 * @see PR #61 BridgeBuilder review â€” Finding 2
 */
export declare const ERROR_HTTP_STATUS: Record<ErrorCode, number>;
//# sourceMappingURL=errors.d.ts.map