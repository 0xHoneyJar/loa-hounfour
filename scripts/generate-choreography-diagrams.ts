/**
 * Generate Mermaid sequence diagrams from TRANSFER_CHOREOGRAPHY.
 *
 * Reads the choreography constant at build time and generates one
 * markdown file per scenario with embedded Mermaid diagrams showing
 * the forward (happy) path and compensation (rollback) path.
 *
 * @see BB-C4-ADV-008 — Choreography could generate Mermaid diagrams
 */
import { mkdirSync, writeFileSync } from 'node:fs';
import { join } from 'node:path';
import { TRANSFER_CHOREOGRAPHY } from '../src/vocabulary/transfer-choreography.js';

const OUT_DIR = join(import.meta.dirname, '..', 'docs', 'choreography');
mkdirSync(OUT_DIR, { recursive: true });

/**
 * Map an event type string to a participant name for the diagram.
 * e.g. 'transfer.saga.initiated' → 'Transfer'
 */
function participantFromEvent(event: string): string {
  const aggregate = event.split('.')[0];
  return aggregate.charAt(0).toUpperCase() + aggregate.slice(1);
}

/**
 * Extract the action from an event type.
 * e.g. 'transfer.saga.initiated' → 'saga.initiated'
 */
function actionFromEvent(event: string): string {
  const parts = event.split('.');
  return parts.slice(1).join('.');
}

function generateDiagram(scenario: string): string {
  const choreo = TRANSFER_CHOREOGRAPHY[scenario as keyof typeof TRANSFER_CHOREOGRAPHY];
  const lines: string[] = [];

  lines.push(`# ${scenario.charAt(0).toUpperCase() + scenario.slice(1)} Transfer Choreography`);
  lines.push('');
  lines.push(`> Auto-generated from \`TRANSFER_CHOREOGRAPHY.${scenario}\`. Do not edit manually.`);
  lines.push('');

  // Forward path
  lines.push('## Forward Path (Happy)');
  lines.push('');
  lines.push('```mermaid');
  lines.push('sequenceDiagram');

  // Collect unique participants in order
  const fwdParticipants = [...new Set(choreo.forward.map(participantFromEvent))];
  for (const p of fwdParticipants) {
    lines.push(`    participant ${p}`);
  }

  lines.push('');
  let prevParticipant = fwdParticipants[0];
  for (const event of choreo.forward) {
    const participant = participantFromEvent(event);
    const action = actionFromEvent(event);
    lines.push(`    ${prevParticipant}->>+${participant}: ${action}`);
    prevParticipant = participant;
  }

  lines.push('```');
  lines.push('');

  // Compensation path
  lines.push('## Compensation Path (Rollback)');
  lines.push('');

  if (choreo.compensation.length === 0) {
    lines.push('_No compensation events defined._');
  } else {
    lines.push('```mermaid');
    lines.push('sequenceDiagram');

    const compParticipants = [...new Set(choreo.compensation.map(participantFromEvent))];
    for (const p of compParticipants) {
      lines.push(`    participant ${p}`);
    }

    lines.push('');
    let prevComp = compParticipants[0];
    for (const event of choreo.compensation) {
      const participant = participantFromEvent(event);
      const action = actionFromEvent(event);
      lines.push(`    ${prevComp}-->>-${participant}: ${action}`);
      prevComp = participant;
    }

    lines.push('```');
  }

  lines.push('');
  lines.push('---');
  lines.push(`*Generated by \`scripts/generate-choreography-diagrams.ts\`*`);
  lines.push('');

  return lines.join('\n');
}

// Generate one file per scenario
for (const scenario of Object.keys(TRANSFER_CHOREOGRAPHY)) {
  const content = generateDiagram(scenario);
  const outPath = join(OUT_DIR, `${scenario}.md`);
  writeFileSync(outPath, content, 'utf8');
  console.log(`Generated: ${outPath}`);
}

console.log(`\n${Object.keys(TRANSFER_CHOREOGRAPHY).length} choreography diagrams generated.`);
